\documentclass[12pt,letterpaper]{article}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage[spanish]{babel} 
\usepackage{graphicx}
\graphicspath{ {screen/} }
\usepackage{enumerate} % enumerados
\usepackage{listings}
\lstset{language=C}

\usepackage{color}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=Octave,                 % the language of the code
  otherkeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}
\usepackage[left=3cm,right=3cm,top=4cm,bottom=3cm]{geometry}

\author{Chávez Soto Luis Armando}
\title{PRÁCTICA 1}
\date{18 de Abril del 2015}

\begin{document}
	
	\maketitle
	
\textbf{1.- Herramientas}
\newline	
\newline	
El Monitor de Actividad (Process Explorer) de Mac OS X 10.10.3, cuenta con los registros de todas las actividades del CPU, memoria, energía, disco y red.
\newline
\newline
Dentro de la sección de CPU podemos decir que tiene un listado de los procesos que se ejecutan, seccionado a nivel de tipo de usuario, root, system, etc, los cuales podemos clasificar por el porcentaje de CPU asignado a cada proceso, el tiempo en el CPU, subprocesos, el número de activaciones desde alguna inactividad y por su puesto su identificador, el PID (Process Identifier).
						
	\includegraphics[width=\linewidth]{herramientascpu}
						
Podemos ver que al seleccionar algún proceso, nos despliega una ventana con información aún más detallada como la memoria real y virtual empleada para la ejecución de dicho proceso.\newline
\newline


	\includegraphics[width=\linewidth]{herramientas_cpu_proceso}

En cuanto a la sección de Memoria podemos apreciar que los procesos se encuentran organizados mediante la memoria que se les es asignada, la memoria compartida, subprocesos asignados a dicho proceso, puertos, el PID y por su puesto el nivel de usuario en cual se encuentran trabajando. 

	\includegraphics[width=\linewidth]{herramientas_memoria}

Mientras que en la sección de ENERGÍA podemos apreciar las aplicaciones con sus procesos y subprocesos que consumen más energía dentro del computador, en la sección de DISCO observamos los bytes escritos en la unidad secundaria de memoria así como los leídos, el tipo de proceso de 32 o 64 bits y en cuanto a RED vemos los procesos que consumen recursos en red, los bytes de entrada y salida. 
El monitor de actividad también nos presenta una sección en donde podemos apreciar mejor estos datos en forma de gráficas.\newline
\newline

\textbf{2.- Señales en Linux y Windows}
\newline
\newline
Primero que nada deberemos aclarar que una señal es una forma limitada de comunicación entre procesos empleada en Unix y otros sistemas operativos compatibles con POSIX, la notificación es asíncrona enviada a un proceso para notificarle sobre un evento. Estas señales o notificaciones se encuentran declarada sobre la librería <signal.h>. Por defecto el mensaje que se envía en una señal es la de terminación SIGTERM, el cual solicita al proceso limpiar su estado y salir. Hay que dejar en claro que el comando Kill no tiene que ver con terminar un proceso.

\begin{itemize}
		\item SIGHUP - Hangup, al salir de la sesión se envía a los processos en Background. Tratamiento por defecto: exit. Reprogramable.
		\item SIGINT - Interrupción, se genera al pulsar "\^c" durante la ejecución. Tratamiento por defecto:exit. Reprogramable.
		\item SIGQUIT - Terminar Pau.
		\item SIGILL - Instrucción ilegal.
		\item SIGTRAP - Trace/breakpoint trap.
		\item SIGABRT - PROCESO abortado.
		\item SIGFPE - Excepción de coma flotante -- "erroneous arithmetic operation"(SUS).
		\item SIGKILL - Destrucción inmediata del proceso.Tratamiento:exit. No reprogramable, no ignorable.
		\item SIGBUS - Error en el bus "access to undefined portion of memory object"(SUS).
		\item SIGSEGV - segmentation violation.Salta con dirección de memoria ilegal. Tratamiento por defecto:exit + volcado de memoria. Reprogramable.
		\item SIGSYS - Error de argumentos al realizar una llamada al sistema llamada al sistema.
		\item SIGPIPE - Se genera al escribir sobre la pipe sin lector. Tratamiento por defecto:exit. Reprogramable.
		\item SIGALRM - Señal de alarma, salta al expirar el timer. Reprogramable.
		\item SIGTERM - Terminación. Tratamiento por defecto:exit. Reprogramable.
		\item SIGURG - datos importantes disponibles en socket
		\item SIGSTOP - Detiene el proceso. Se genera al pulsar "\^z" durante la ejecución. No reprogramable, no ignorable.
	\end{itemize}

Entre otras señales.\newline

En cuanto a Microsoft Windows, opera bajo un comando taskkill para finalizar procesos.\newline\newline

	\includegraphics[width=\linewidth]{senales_terminal}

\textbf{3.- Wait()}

Existe la llamada wait() para que un proceso padre espere la respuesta de su proceso hijo, o hasta que se produce una señal cuya acción es terminar el proceso actual o llamar a la función manejadora de la señal. Si un hijo ha salido cuando se produce la llamada (lo que se entiende por proceso "zombie"), la función vuelve inmediatamente. Todos los recursos del sistema reservados por el hijo son liberados.\newline\newline

El valor que tenga el parámetro PID tiene los siguientes significados:

\begin{itemize}
	\item < -1: Esperar por cualquier hijo cuyo ID de grupo sea igual al valor del pid (con el signo cambiado).
	\item -1: Esperar por el primer hijo que termine.
	\item 0: Esperar por cualquier hijo cuyo identificador de grupo sea igual al pid del proceso llamador (padre).
	\item 0: Esperar por los hijos cuyo pid es el indicado.
\end{itemize}

El estándar POSIX original estableció como indefinido el comportamiento de tratar SIGCHLD con SIG\_IGN. Estándares posteriores, incluyendo SUSv2 y POSIX 1003.1-2001 especifican este comportamiento describiéndolo tan solo como una opción conforme con XSI. Linux no es conforme con el segundo de los dos puntos recién descritos: si se hace una llamada a wait() mientras SIGCHLD está siendo ignorada, la llamada se comporta como si SIGCHLD no estuviera siendo ignorada, es decir, se bloquea hasta que el siguiente hijo termina y luego devuelve el PID y el estado de ese hijo.
\newline\newline

\textbf{4.- Programas con fork()}

\newcounter{nx}

\begin{enumerate}[(A)]
	 \item Programa 1 (C en Linux)
	 \setcounter{nx}{\value{enumi}} 
\end{enumerate}

En resumen el programa solo estar el proceso padre que genera al proceso hijo, indicando su PID, después salvamos el PID del proceso hijo al ejecutar la función fork(), a continuación tenemos un método preventivo en caso de que falle la creación del nuevo proceso. A continuación ejecutamos un comando del sistema, Proccess Status, para ver los procesos activos mediante su PID, TTY, su tiempo de ejecución y su jerarquía. Inmediatamente los procesos comienzan a ejecutar el resto del código al mismo tiempo, por consecuente separamos al proceso padre del hijo mediante una condicional, cada procesos ejecutara una serie de letras en pantalla y dormir un determinado tiempo en caso del proceso padre pondrá ,a, en caso del proceso hijo será b.

	\includegraphics[width=\linewidth]{run_programa_1}

\begin{enumerate}[(A)]
	\setcounter{enumi}{\value{nx}} 
    	\item Programa 2 (Microsoft Visual C++ Express 2010)
\end{enumerate}

En resumen el programa solo genera hilos a petición del usuario. Y muestra el numero de hilos que se están ejecutando, este espera a que termine y enseguida sigue iterando el ciclo for.
\newline
\newline

	\includegraphics[width=\linewidth]{run_programa_2}


\begin{enumerate}[(A)]
	\setcounter{enumi}{\value{nx}} 
    	\item Programa 3 (Java)
\end{enumerate}

El código se divideo en dos partes esenciales, la primera es una clase llamada GeneraHiloM que extiende de la clase Thread, dicha clase se encarga de crear un hilo con una ejecución en donde crea un tiempo aleatorio en el cual dormir el hilo e imprimir su nombre y el tiempo que durmió. La siguiente parte será el programa principal, en donde se crean 6 objetos instancias de la clase GeneraHiloM, se les asigna un nombre y a continuación se inician. Pero dependiendo el tiempo que se le fue asignado para dormir al hilo, será como terminen pues no terminaran de forma consecutiva.

	\includegraphics[width=\linewidth]{run_programa_3}
	
	
	
\begin{enumerate}[(A)]
	\setcounter{enumi}{\value{nx}} 
    	\item Programa 4 (Java)
\end{enumerate}

Un programa muy similar al pasado, esta vez la clase es una extensión de Thread, donde existe una sobrecarga de los métodos nativos de la clase Thread. Se crean 5 hilos pero con em método join(), en donde este tiene la función de esperar la ejecución de un hilo para comenzar el siguiente. Cada hilo tiene como actividad una cuenta de 5 hasta 1, y duerme durante 100 ms. Al terminar cada hilo, por consiguiente se ejecuta en siguiente.

	\includegraphics[width=\linewidth]{run_programa_4}

\textbf{5.- Programas con fork()}
\newline
\newline
\begin{lstlisting}
//
//  programa_fork.c
//  
//
//  Created by Luis Armando Chávez Soto on 17/04/15.
//
//

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>  /* waitpid */
#include <math.h>


#define clear() printf("\033[H\033[J")

void serieFibonaccio(int iteraciones);
void raices();
void suma();

int main(){
    clear();

    // Identificador
    pid_t pid;
    int i;
    
    // Verificamos proceso padre
    printf("Proceso padre: %d\n\n",getppid());
    
    // Ciclo para la creación del los procesos, asi mismo la asignación de tareas para cada proceso
    for (i = 0; i < 3; ++i) {
        pid = fork();
        if (pid) {
            
            // Ponemos al padre a esperar cada proceso hijo
            int status;
            wait(&status);
            
            continue;
        } else if (pid == 0) {
            //printf("Hijo (%d): %d\n", i + 1, getpid());
            switch (i) {
                case 0:
                    sleep(2);
                    clear();
                    printf("---> Raiz (1er Proceso PID: %d)\n",getpid());
                    raices();
                    break;
                case 1:
                    sleep(3);
                    clear();
                    printf("---> Fibonacci (2do Proceso PID: %d)\n",getpid());
                    int iteraciones = obtenerNumeroFibo();
                    serieFibonaccio(iteraciones);
                    break;
                case 2:
                    sleep(3);
                    clear();
                    printf("---> Suma de los elementos de un arreglo (3er Proceso PID: %d)\n",getpid());
                    suma();
                    break;
                    
            }
            
            break;
        } else {
            printf("Error Fork\n");
            exit(1);
        }
    }
}

// Respectivas funciones para Fibonacci, Raices y suma de los elementos de un arreglo.

int obtenerNumeroFibo(){
    int num;
    do{
        printf("Necesitamos que nos des un numero de iteraciones para la serie de Fibonacci (0-99): \n");
        scanf("%d",&num);
        
        if (num < 0 || num > 99) {
            //clear();
            printf("\n\n *** Error con numero de iteraciones deseadas ***\n\n\n");
        }
        
    }while (num < 0 || num > 99);

    return num;
}

void serieFibonaccio(int iteraciones){

    int i;
    int prim = 0;
    int segu = 1;
    int sig;
    
    printf("Serie: \n");
    
    for (i = 0; i < iteraciones; i++) {
        if (i <= 1) {
            sig = i;
        }else{
            sig = prim + segu;
            prim = segu;
            segu = sig;
        }
        printf("%d - ",sig);
    }
    
    printf("\n\n\n");

}

void raices(){
    
    int tamanio;
    do {
        printf("Tamaño del arreglo (1 - 20): \n");
        scanf("%d",&tamanio);
        
        if (tamanio < 1 || tamanio > 20) {
            //clear();
            printf("\n\n *** Error con el tamanio del arreglo deseado ***\n\n\n");
        }
        
    } while (tamanio < 1 || tamanio > 20);
    
    int arreglo [tamanio];
    int i;
    
    printf("\nLlene el arreglo con valores entre 0 y 99\n");
    
    int dato;
    for (i = 0; i < tamanio ; i++) {
        
        do {
            printf("\nArreglo[%d] - ",i);
            scanf("%d",&dato);
            
            if (dato < 0 || dato > 99) {
                //clear();
                printf("\n\n *** Error con el dato, fuera de rango ***\n\n\n");
            }else{
                arreglo[i] = dato;
            }
            
        } while (dato < 0 || dato > 99);
        
    }
    
    
    printf("\nArreglo lleno.\n");
    
    printf("Iteracion \tValor \tRaiz\n");
    for (i = 0; i < tamanio; i++) {
        if (arreglo [i] < 0) {
            printf("Arreglo[%d] \t%d \tMath ERROR",i,arreglo[i]);
        }else{
            printf("Arreglo[%d] \t%d \t%f",i, arreglo[i],sqrt(arreglo[i]));
        }
        printf("\n");
    }


    printf("\n\n\n");

    

}

void suma(){
    int tamanio;
    do {
        printf("Tamaño del arreglo (1 - 20): \n");
        scanf("%d",&tamanio);
        
        if (tamanio < 1 || tamanio > 20) {
            //clear();
            printf("\n\n *** Error con el tamanio del arreglo deseado ***\n\n\n");
        }
        
    } while (tamanio < 1 || tamanio > 20);
    
    int arreglo [tamanio];
    int i;
    
    printf("\nLlene el arreglo con valores entre 0 y 99\n");
    
    int dato;
    for (i = 0; i < tamanio ; i++) {
        
        do {
            printf("\nArreglo[%d] - ",i);
            scanf("%d",&dato);
            
            if (dato < 0 || dato > 99) {
                //clear();
                printf("\n\n *** Error con el dato, fuera de rango ***\n\n\n");
            }else{
                arreglo[i] = dato;
            }
            
        } while (dato < 0 || dato > 99);
        
    }
    printf("\nArreglo lleno.\n");
    
    int dat = 0;
    
    for (i = 0; i < tamanio; i++) {
        dat = dat + arreglo[i];
    }
    
    printf("Sumatoria de los elementos del arreglo: %d",dat);
    
    printf("\n\n\n");
}


\end{lstlisting}



\begin{lstlisting}
//
//  programa_pthread.c
//  
//
//  Created by Luis Armando Chávez Soto on 18/04/15.
//
//

#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <stdint.h> /* 64 bits */

#define clear() printf("\033[H\033[J")


void *helloWorld(void *numHilo)
{
    int i,hilo;
    
    hilo =  (int) numHilo;
    
    for (i=0; i<5; i++){
        printf("Hola Mundo [%d]\n",hilo);
    }
    pthread_exit((void*) numHilo);
}

int main()
{
    // Limpiamos Pantalla
    clear();
    
    // Arreglo de hilos
    pthread_t thread[10];
    pthread_attr_t attr;
    
    // Contador y rc
    int rc, i;
    void *status;
    
    // Inicializador y tipo de Hilo
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
    
    // Ciclo para crear hilo con surespectiva función y paso de argumento
    for(i=0;i<10;i++)
    {

        int *numHilo;
        numHilo = i+1;
        rc = pthread_create(&thread[i], &attr, helloWorld, (void *)numHilo);
        if (rc){
            printf("ERROR: pthread_create() -> %d\n", rc);
            exit(EXIT_FAILURE);
        }
    }
    
    // Destruccón del hilo
    pthread_attr_destroy(&attr);
    
    // Estado final del hilo
    for(i=0;i<10;i++)
    {
        rc = pthread_join(thread[i], &status);
        
        if (rc){
            printf("ERROR: pthread_join() -> %d\n", rc);
            exit(EXIT_FAILURE);
        }
    }
    
    pthread_exit(NULL);
} 
\end{lstlisting}

\textbf{Bibliografía}
 
\begin{itemize}
		\item Señales (Wikipedia) - http://es.wikipedia.org/wiki/Señal\_(informática)
		\item Signals and Traps (TutorialPoints) - http://www.tutorialspoint.com/unix/unix-signals-traps.htm				\item Kill (Wikipedia) - http://es.wikipedia.org/wiki/Kill
		\item TaskKill (Microsoft) - http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/taskkill.mspx?mfr=true
		\item Ps, Unix (Wikipedia) - http://en.wikipedia.org/wiki/Ps\_(Unix)
		\item Windows Data Types (Microsoft) - https://msdn.microsoft.com/en-us/library/windows/desktop/aa383751\%28v=vs.85\%29.aspx
		\item \_BeginThread Doc (Microsoft) - https://msdn.microsoft.com/es-mx/library/kdzttdcb.aspx
		\item WaitForSingleObject Doc (Microsoft) - https://msdn.microsoft.com/en-us/library/windows/desktop/ms687032\%28v=vs.85\%29.aspx
		\item Join (Oracle) - https://docs.oracle.com/javase/tutorial/essential/concurrency/join.html
	\end{itemize} 
 
\end{document}


\end{document}
